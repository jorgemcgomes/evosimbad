/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * Aggregator.java
 *
 * Created on 4/Dez/2011, 12:13:16
 */
package evosimbad.gui;

import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.*;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOCase;
import org.apache.commons.io.filefilter.FileFilterUtils;
import org.apache.commons.io.filefilter.IOFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;
import org.apache.commons.lang3.tuple.Pair;

/**
 *
 * @author Jorge * Best so far - AVG ; Best so far - ALL ; Best fit - AVG ; Best
 * fit - ALL ; Average fit - AVG ; Best neurons - AVG ; Best links - AVG ; Avg
 * neurons - AVG ; Avg links - AVG
 *
 */
public class Aggregator extends javax.swing.JFrame {
    
    public static final char SEPARATOR = '\t';
    private JFileChooser baseChooser;

    /**
     * Creates new form Aggregator
     */
    public Aggregator() {
        initComponents();
        baseChooser = new JFileChooser();
        baseChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        aggregationText.setText("Best so far - AVG ;\nBest so far - ALL ;\nBest fit - AVG ;\nBest fit - ALL ;\nAverage fit - AVG ;\nBest neurons - AVG ;\nBest links - AVG ;\nAvg neurons - AVG ;\nAvg links - AVG");
        filterField.setText("fitLog.csv");
    }
    
    public Aggregator(File baseFolder) {
        this();
        baseFolderField.setText(baseFolder.getAbsolutePath());
        nameField.setText(baseFolder.getName());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        baseFolderLabel = new javax.swing.JLabel();
        baseFolderField = new javax.swing.JTextField();
        baseFolderChoose = new javax.swing.JButton();
        nameLabel = new javax.swing.JLabel();
        nameField = new javax.swing.JTextField();
        aggregationLabel = new javax.swing.JLabel();
        textAreaScroll = new javax.swing.JScrollPane();
        aggregationText = new javax.swing.JTextArea();
        goButton = new javax.swing.JButton();
        filterField = new javax.swing.JTextField();
        filterLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Aggregator");

        baseFolderLabel.setText("Base folder:");

        baseFolderChoose.setText("Choose folder");
        baseFolderChoose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                baseFolderChooseActionPerformed(evt);
            }
        });

        nameLabel.setText("Name:");

        nameField.setText("exp");

        aggregationLabel.setText("Column Aggregation:");

        aggregationText.setColumns(20);
        aggregationText.setRows(5);
        textAreaScroll.setViewportView(aggregationText);

        goButton.setText("Go!");
        goButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                goButtonActionPerformed(evt);
            }
        });

        filterLabel.setText("Name filter:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(textAreaScroll, javax.swing.GroupLayout.DEFAULT_SIZE, 421, Short.MAX_VALUE)
                    .addComponent(aggregationLabel)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(nameLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(nameField, javax.swing.GroupLayout.DEFAULT_SIZE, 281, Short.MAX_VALUE)
                        .addGap(56, 56, 56)
                        .addComponent(goButton))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(filterField, javax.swing.GroupLayout.PREFERRED_SIZE, 106, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(filterLabel))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(baseFolderLabel)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(baseFolderField, javax.swing.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(baseFolderChoose, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(baseFolderLabel)
                    .addComponent(filterLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(baseFolderChoose)
                    .addComponent(baseFolderField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(filterField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(aggregationLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(textAreaScroll, javax.swing.GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(goButton)
                    .addComponent(nameLabel)
                    .addComponent(nameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

private void baseFolderChooseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_baseFolderChooseActionPerformed
    int returnVal = baseChooser.showOpenDialog(this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File base = baseChooser.getSelectedFile();
        baseFolderField.setText(base.getAbsolutePath());
        nameField.setText(base.getName());
    }
    
}//GEN-LAST:event_baseFolderChooseActionPerformed
    
private void goButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_goButtonActionPerformed
    JFileChooser chooser = new JFileChooser();
    chooser.setSelectedFile(new File(baseFolderField.getText(), nameField.getText() + ".csv"));
    int returnVal = chooser.showSaveDialog(this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File output = chooser.getSelectedFile();
        try {
            aggregate(new File(baseFolderField.getText()), filterField.getText(), nameField.getText(), aggregationText.getText(), output);
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            ex.printStackTrace();
        }
    }
}//GEN-LAST:event_goButtonActionPerformed
    private static final String[] OPTIONS = new String[]{"ALL", "AVG", "MAX", "MIN"};
    
    static protected void aggregate(File base, String fileName, String expName, String config, File output) throws Exception {
        /*
         * Find files
         */
        IOFileFilter filter = FileFilterUtils.suffixFileFilter(".csv", IOCase.INSENSITIVE);
        if (!fileName.equals("")) {
            filter = FileFilterUtils.and(filter, FileFilterUtils.nameFileFilter(fileName));
        }
        Collection<File> rawList = FileUtils.listFiles(base, filter, TrueFileFilter.TRUE);
        ArrayList<File> csvList = new ArrayList<>(rawList);
        Collections.sort(csvList);

        /*
         * Open files
         */
        System.out.println("Going to aggregate " + csvList.size() + " files");
        List<CSVReader> readers = new ArrayList<>(csvList.size());
        for (File csv : csvList) {
            readers.add(new CSVReader(new FileReader(csv), SEPARATOR));
        }

        /*
         * Map the columns of each file
         */
        ArrayList<HashMap<String, Integer>> columnMaps = new ArrayList<>();
        for (CSVReader r : readers) {
            String[] header = r.readNext();
            HashMap<String, Integer> map = new HashMap<>();
            for (int i = 0; i < header.length; i++) {
                String colName = header[i].trim().toLowerCase().replace(" ", ".");
                map.put(colName, i);
            }
            columnMaps.add(map);
        }

        /*
         * Interpret the options
         */
        String[] params = config.replace("\n", "").replace("\t", "").split(";");
        ArrayList<Pair<String, Integer>> transforms = new ArrayList<>(params.length);
        for (String p : params) {
            String[] split = p.split("-");
            String colName = split[0].trim().toLowerCase().replace(" ", ".");
            String option = split[1].trim();
            int optionIndex = -1;
            for (int i = 0; i < OPTIONS.length; i++) {
                if (OPTIONS[i].equalsIgnoreCase(option)) {
                    optionIndex = i;
                    break;
                }
            }
            if (optionIndex == -1 || colName == null) {
                throw new Exception("Inexistent column name or option in " + p);
            } else {
                transforms.add(Pair.of(colName, optionIndex));
            }
        }

        /*
         * Build the header
         */
        ArrayList<String> outputHeader = new ArrayList<>();
        for (Pair<String, Integer> t : transforms) {
            switch (t.getRight()) {
                case 0: // ALL
                    for (int i = 0; i < readers.size(); i++) {
                        outputHeader.add(expName + "." + t.getLeft() + "." + i);
                    }
                    break;
                case 1: // AVG
                    outputHeader.add(expName + "." + t.getLeft() + ".AVG");
                    break;
                case 2: // MAX
                    outputHeader.add(expName + "." + t.getLeft() + ".MAX");
                    break;
                case 3: // MIN
                    outputHeader.add(expName + "." + t.getLeft() + ".MIN");
                    break;
            }
        }

        /*
         * Open the output file and write the header
         */
        CSVWriter writer = new CSVWriter(new BufferedWriter(new FileWriter(output)), '\t');
        String[] outHeader = new String[outputHeader.size()];
        outHeader = outputHeader.toArray(outHeader);
        System.out.println(Arrays.toString(outHeader));
        writer.writeNext(outHeader);

        /*
         * WRITE THE CONTENT
         */
        HashSet<CSVReader> deadReaders = new HashSet<>();
        while (true) {
            System.out.print(".");
            List<String[]> lines = new ArrayList<>(readers.size());
            // Check what files reach the end
            for (CSVReader reader : readers) {
                if (deadReaders.contains(reader)) {
                    lines.add(null);
                } else {
                    String[] line = reader.readNext();
                    if (line == null || !line[0].matches("((-|\\+)?[0-9]+(\\.[0-9]+)?)+")) { // se nao for um numero - messy fix para detectar novos headers
                        deadReaders.add(reader);
                        lines.add(null);
                    } else {
                        lines.add(line);
                    }
                }
            }
            if (deadReaders.size() == readers.size()) { // ALL DEAD
                break;
            }

            // Write the line
            List<String> newLine = new ArrayList<>(outHeader.length);
            for (Pair<String, Integer> t : transforms) {
                String transformCol = t.getLeft();
                switch (t.getRight()) {
                    case 0: // ALL
                        for (int i = 0; i < lines.size(); i++) {
                            String[] l = lines.get(i);
                            if (l != null && columnMaps.get(i).containsKey(transformCol)) {
                                newLine.add(l[columnMaps.get(i).get(transformCol)]);
                            } else {
                                newLine.add("");
                            }
                        }
                        break;
                    case 1: // AVG
                        double avg = 0;
                        int count = 0;
                        for (int i = 0; i < lines.size(); i++) {
                            String[] l = lines.get(i);
                            if (l != null && columnMaps.get(i).containsKey(transformCol)) {
                                avg += Double.parseDouble(l[columnMaps.get(i).get(transformCol)]);
                                count++;
                            }
                        }
                        if (count > 0) {
                            newLine.add(Double.toString(avg / count));
                        } else {
                            newLine.add("NA");
                        }
                        break;
                    case 2: // MAX
                        double max = Double.NEGATIVE_INFINITY;
                        for (int i = 0; i < lines.size(); i++) {
                            String[] l = lines.get(i);
                            if (l != null && columnMaps.get(i).containsKey(transformCol)) {
                                max = Math.max(Double.parseDouble(l[columnMaps.get(i).get(transformCol)]), max);
                            }
                        }
                        if (max != Double.NEGATIVE_INFINITY) {
                            newLine.add(Double.toString(max));
                        } else {
                            newLine.add("NA");
                        }
                        break;
                    case 3: // MIN
                        double min = Double.POSITIVE_INFINITY;
                        for (int i = 0; i < lines.size(); i++) {
                            String[] l = lines.get(i);
                            if (l != null && columnMaps.get(i).containsKey(transformCol)) {
                                min = Math.min(Double.parseDouble(l[columnMaps.get(i).get(transformCol)]), min);
                            }
                        }
                        if (min != Double.POSITIVE_INFINITY) {
                            newLine.add(Double.toString(min));
                        } else {
                            newLine.add("NA");
                        }
                        break;
                }
            }
            String[] l = new String[newLine.size()];
            writer.writeNext(newLine.toArray(l));
        }
        writer.close();
        for (CSVReader r : readers) {
            r.close();
        }        
        System.out.println();
        System.out.println("DONE");
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Aggregator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Aggregator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Aggregator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Aggregator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Aggregator().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel aggregationLabel;
    private javax.swing.JTextArea aggregationText;
    private javax.swing.JButton baseFolderChoose;
    private javax.swing.JTextField baseFolderField;
    private javax.swing.JLabel baseFolderLabel;
    private javax.swing.JTextField filterField;
    private javax.swing.JLabel filterLabel;
    private javax.swing.JButton goButton;
    private javax.swing.JTextField nameField;
    private javax.swing.JLabel nameLabel;
    private javax.swing.JScrollPane textAreaScroll;
    // End of variables declaration//GEN-END:variables
}
